---
- name: Set modules
  copy:
    dest: /mnt/etc/mkinitcpio.conf
    force: yes
    content: |
      MODULES=(hv_storvsc hv_vmbus hv_netvsc zram virtio virtio_pci virtio_net virtio_blk)
      BINARIES=()
      FILES=()
      HOOKS=(systemd systemd-tool autodetect microcode modconf kms keyboard sd-vconsole block initrd_zram luks_unlocker sd-encrypt filesystems)
      COMPRESSION="zstd"
      COMPRESSION_OPTIONS=(-9)

- name: Set modules for fallback
  copy:
    dest: /mnt/etc/mkinitcpio-fallback.conf
    force: yes
    content: |
      MODULES=(hv_storvsc hv_vmbus hv_netvsc zram virtio virtio_pci virtio_net virtio_blk)
      BINARIES=()
      FILES=()
      HOOKS=(systemd systemd-tool autodetect microcode modconf kms keyboard sd-vconsole block initrd_zram sd-encrypt filesystems)
      COMPRESSION="zstd"
      COMPRESSION_OPTIONS=(-9)

- name: Create /etc/cmdline.d directory
  ansible.builtin.file:
    path: /mnt/etc/cmdline.d
    state: directory

- name: Create /etc/cmdline.d/default directory
  ansible.builtin.file:
    path: /mnt/etc/cmdline.d/default
    state: directory

- name: Create /etc/cmdline.d/fallback directory
  ansible.builtin.file:
    path: /mnt/etc/cmdline.d/fallback
    state: directory

- name: Get the UUID of the LUKS partition at {{ install_device_name }}{{ root_partition_number }}
  command: blkid -s UUID -o value {{ install_device_name }}{{ root_partition_number }}
  register: luks_partition_uuid

- name: set cmdline root conf for UKI
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/cmdline.d/default/root.conf
    content: |
      root=/dev/mapper/{{ luks_root_name }} rootflags=subvol=@ rw rd.neednet=1 console=tty0 console=ttyS0,115200 bgrt_disable lsm=landlock,lockdown,yama,integrity,apparmor,bpf slab_nomerge init_on_alloc=1 init_on_free=1 page_alloc.shuffle=1 pti=on randomize_kstack_offset=on vsyscall=none debugfs=off oops=panic intel_iommu=on amd_iommu=on

- name: set cmdline fallback conf for UKI
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/cmdline.d/fallback/root.conf
    content: |
      rd.luks.name={{ luks_partition_uuid.stdout }}={{ luks_root_name }} root=/dev/mapper/{{ luks_root_name }} rootflags=subvol=@ rw rd.neednet=1 console=tty0 console=ttyS0,115200 bgrt_disable lsm=landlock,lockdown,yama,integrity,apparmor,bpf slab_nomerge init_on_alloc=1 init_on_free=1 page_alloc.shuffle=1 pti=on randomize_kstack_offset=on vsyscall=none debugfs=off oops=panic intel_iommu=on amd_iommu=on

- name: Create systemd-networkd config directory
  ansible.builtin.file:
    path: /mnt/etc/systemd/network
    state: directory

- name: Create mkinitcpio-systemd-tool config directory
  ansible.builtin.file:
    path: /mnt/etc/mkinitcpio-systemd-tool/config
    state: directory

- name: Configure initrd network (DHCP) for systemd-tool
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/mkinitcpio-systemd-tool/config/initrd-network.network
    content: |
      [Match]
      Name=en*
      Name=eth*

      [Network]
      DHCP=yes
      DNS=9.9.9.9
      DNS=1.1.1.1

- name: Configure runtime network (DHCP)
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/systemd/network/20-wired.network
    content: |
      [Match]
      Name=en*
      Name=eth*

      [Network]
      DHCP=yes
      DNS=9.9.9.9
      DNS=1.1.1.1

- name: set /etc/mkinitcpio.d/{{ kernel }}.preset
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/mkinitcpio.d/{{ kernel }}.preset
    content: |
      ALL_kver="/boot/vmlinuz-{{ kernel }}"
      PRESETS=('default' 'fallback')
      default_uki="/efi/EFI/Linux/arch-linux.efi"
      default_config="/etc/mkinitcpio.conf"
      default_options="--cmdline /etc/cmdline.d/default/root.conf"
      fallback_uki="/efi/EFI/Linux/arch-linux-fallback.efi"
      fallback_options="--cmdline /etc/cmdline.d/fallback/root.conf -S autodetect"
      fallback_config="/etc/mkinitcpio-fallback.conf"

- name: Set initrd_zram install hook
  copy:
    dest: /mnt/etc/initcpio/install/initrd_zram
    force: yes
    content: |
      #!/bin/bash

      build() {
          # zram-generator: generator binary, template service, config, and tools
          add_binary /usr/lib/systemd/system-generators/zram-generator
          add_systemd_unit systemd-zram-setup@.service
          add_file /etc/systemd/zram-generator.conf
          add_binary /usr/bin/zramctl
          add_binary /usr/bin/mkswap
          add_binary /usr/bin/swapon
      }

      help() {
          cat <<HELPEOF
      Includes zram-generator and its dependencies in the initramfs
      so that zram swap is available during early boot.
      HELPEOF
      }

- name: Ensure /etc/initcpio/install/initrd_zram is executable
  file:
    path: /mnt/etc/initcpio/install/initrd_zram
    mode: "0755"

- name: Set luks_unlocker install
  copy:
    dest: /mnt/etc/initcpio/install/luks_unlocker
    force: yes
    content: |
      #!/bin/bash

      build() {
          add_binary /usr/local/bin/luks_unlocker /usr/local/bin/luks_unlocker
          add_systemd_unit luks_unlocker.service
          add_systemd_unit cryptsetup-pre.target

          # Enable the service by creating the .wants/ symlink.
          # add_systemd_unit only copies the unit file — it does NOT process
          # the [Install] section, so WantedBy= has no effect without this.
          add_symlink "/usr/lib/systemd/system/initrd.target.wants/luks_unlocker.service" \
                      "/usr/lib/systemd/system/luks_unlocker.service"

          # libnss_files.so is loaded via dlopen() — needed for passwd/group
          # lookups from /etc/passwd and /etc/group in the initramfs.
          # nsswitch.conf is already provisioned by the base systemd hook.
          local nss
          for nss in /usr/lib/libnss_files.so*; do
              [ -e "$nss" ] && add_binary "$nss"
          done

          # Add systemd-network and systemd-resolve users/groups/shadow to initramfs
          # (systemd-sysusers is not available in early boot)
          local user
          for user in systemd-network systemd-resolve; do
              grep -q "^${user}:" "$BUILDROOT/etc/passwd" || \
                  grep "^${user}:" /etc/passwd >> "$BUILDROOT/etc/passwd"
              grep -q "^${user}:" "$BUILDROOT/etc/group" || \
                  grep "^${user}:" /etc/group >> "$BUILDROOT/etc/group"
              grep -q "^${user}:" "$BUILDROOT/etc/shadow" 2>/dev/null || \
                  grep "^${user}:" /etc/shadow >> "$BUILDROOT/etc/shadow" 2>/dev/null
          done
      }

      help() {
          cat <<HELPEOF
      HELPEOF
      }

- name: Ensure /etc/initcpio/install/luks_unlocker
  file:
    path: /mnt/etc/initcpio/install/luks_unlocker
    mode: "0755"

- name: Set luks_unlocker install
  copy:
    dest: /mnt/usr/lib/systemd/system/luks_unlocker.service
    force: yes
    content: |
      [Unit]
      Description=Unlock LUKS with KeyVault
      Before=cryptsetup-pre.target initrd-root-device.target
      DefaultDependencies=no
      Wants=systemd-networkd.service systemd-resolved.service
      After=systemd-networkd.service systemd-resolved.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes

      ExecStart=/bin/sh -c '/usr/lib/systemd/systemd-cryptsetup attach {{ luks_root_name }} /dev/disk/by-uuid/{{ luks_partition_uuid.stdout }} - tpm2-device=auto,headless=true || /usr/local/bin/luks_unlocker'
      Restart=on-failure
      RestartSec=10s
      StartLimitIntervalSec=60s
      StartLimitBurst=6
      StandardError=journal+console
      StandardOutput=journal+console

      [Install]
      WantedBy=initrd.target

- name: Download luks_unlocker zip
  get_url:
    url: https://github.com/mgugger/azure-keyvault-unlock-luks/releases/download/v0.0.1/azure-keyvault-unlock-luks_x86_64.zip
    dest: /tmp/luks_unlocker.zip

- name: Unpack luks_unlocker zip
  unarchive:
    src: /tmp/luks_unlocker.zip
    dest: /mnt/usr/local/bin
    remote_src: yes

- name: Ensure luks_unlocker is executable
  file:
    path: /mnt/usr/local/bin/luks_unlocker
    mode: "0755"

- name: Install first-boot TPM enroll script
  copy:
    dest: /mnt/usr/local/bin/enroll-tpm-all.sh
    mode: "0755"
    force: yes
    content: |
      #!/bin/bash
      set -euo pipefail
      for dev in $(blkid -t TYPE=crypto_LUKS -o device); do
        if cryptsetup isLuks --type luks2 "$dev" 2>/dev/null; then
          if cryptsetup luksDump "$dev" | grep -q 'tpm2'; then
            echo "TPM2 token already enrolled on $dev, skipping"
          else
            echo "Enrolling TPM2 on $dev"
            systemd-cryptenroll --tpm2-device=auto "$dev"
          fi
        fi
      done

- name: Install first-boot TPM enroll service
  copy:
    dest: /mnt/etc/systemd/system/enroll-tpm.service
    force: yes
    content: |
      [Unit]
      Description=Enroll TPM2 key for all LUKS2 devices
      ConditionFirstBoot=yes

      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/enroll-tpm-all.sh

      [Install]
      WantedBy=multi-user.target

- name: Enable first-boot TPM enroll service
  command:
    argv:
      - /usr/bin/systemctl
      - --root=/mnt
      - enable
      - enroll-tpm.service

- name: Write /etc/kernel/uki.conf
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/kernel/uki.conf
    content: |
      [UKI]
      SecureBootPrivateKey=/etc/kernel/secure-boot-private-key.pem
      SecureBootCertificate=/etc/kernel/secure-boot-certificate.pem

- name: Install UKI tooling in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/pacman
      - -S
      - --noconfirm
      - systemd-ukify
      - mkinitcpio-systemd-tool
      - sbsigntools

- name: Enable initrd-network.service in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/systemctl
      - enable
      - initrd-network.service

- name: Enable systemd-resolved in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/systemctl
      - enable
      - systemd-resolved.service

- name: Set timezone symlink in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/ln
      - -sf
      - /usr/share/zoneinfo/CET
      - /etc/localtime

- name: Sync hardware clock in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/hwclock
      - --systohc

- name: Generate locales in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/locale-gen

- name: Set root password in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /bin/bash
      - -c
      - echo -e "{{root_pw}}\n{{root_pw}}" | passwd

- name: Ensure EFI Linux output directory exists in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/mkdir
      - -p
      - /efi/EFI/Linux

- name: Ensure /etc/kernel exists in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/mkdir
      - -p
      - /etc/kernel

- name: Generate Secure Boot keys with ukify in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/ukify
      - genkey
      - --config
      - /etc/kernel/uki.conf

- name: Generate UKIs with mkinitcpio preset in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/mkinitcpio
      - -p
      - "{{ kernel }}"

- name: Sign systemd-boot EFI binary in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/lib/systemd/systemd-sbsign
      - sign
      - --private-key
      - /etc/kernel/secure-boot-private-key.pem
      - --certificate
      - /etc/kernel/secure-boot-certificate.pem
      - --output
      - /usr/lib/systemd/boot/efi/systemd-bootx64.efi.signed
      - /usr/lib/systemd/boot/efi/systemd-bootx64.efi

- name: Show free space on ESP (/mnt/efi)
  command:
    argv:
      - /usr/bin/df
      - -h
      - /mnt/efi
  register: esp_df

- name: Print ESP free space
  debug:
    var: esp_df.stdout_lines

- name: Install systemd-boot with Secure Boot
  command:
    argv:
      - /usr/bin/bootctl
      - --root=/mnt
      - install
      - --certificate
      - /mnt/etc/kernel/secure-boot-certificate.pem
      - --private-key
      - /mnt/etc/kernel/secure-boot-private-key.pem

- name: Verify EFI Linux directory exists on ESP
  stat:
    path: /mnt/efi/EFI/Linux
  register: efi_linux_dir

- name: Fail if EFI Linux directory is missing
  fail:
    msg: "Missing /mnt/efi/EFI/Linux after kernel build; UKI artifacts were not generated on the ESP."
  when: not efi_linux_dir.stat.exists or not efi_linux_dir.stat.isdir

- name: Find generated UKI artifacts in EFI/Linux
  find:
    paths: /mnt/efi/EFI/Linux
    patterns: "*.efi"
    file_type: file
  register: efi_uki_files

- name: Fail if no UKI artifacts were generated in EFI/Linux
  fail:
    msg: "No UKI .efi files found in /mnt/efi/EFI/Linux after kernel build."
  when: efi_uki_files.matched | int == 0

- name: Export Secure Boot db certificate for build output
  command:
    argv:
      - /usr/bin/cp
      - /mnt/etc/kernel/secure-boot-certificate.pem
      - /tmp/secureboot-cert.pem

- name: Create pacman hooks directory for Secure Boot
  ansible.builtin.file:
    path: /mnt/etc/pacman.d/hooks
    state: directory

- name: Install secure boot resign script
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/usr/local/bin/secure-boot-resign
    mode: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail
      /usr/bin/mkinitcpio -P {{ kernel }}
      /usr/lib/systemd/systemd-sbsign sign \
        --private-key /etc/kernel/secure-boot-private-key.pem \
        --certificate /etc/kernel/secure-boot-certificate.pem \
        --output /usr/lib/systemd/boot/efi/systemd-bootx64.efi.signed \
        /usr/lib/systemd/boot/efi/systemd-bootx64.efi

- name: Add pacman hook to resign boot artifacts
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/pacman.d/hooks/90-sbctl-resign.hook
    content: |
      [Trigger]
      Operation = Install
      Operation = Upgrade
      Type = Package
      Target = {{ kernel }}
      Target = mkinitcpio
      Target = systemd
      Target = systemd-boot

      [Action]
      Description = Regenerate UKIs and sign systemd-boot
      When = PostTransaction
      Exec = /usr/local/bin/secure-boot-resign

- name: Install TPM re-enroll script
  copy:
    dest: /mnt/usr/local/bin/reenroll-tpm-all.sh
    mode: "0755"
    owner: root
    group: root
    force: yes
    content: |
      #!/bin/bash
      set -euo pipefail
      for dev in $(blkid -t TYPE=crypto_LUKS -o device); do
        if cryptsetup isLuks --type luks2 "$dev" 2>/dev/null; then
          if cryptsetup luksDump "$dev" | grep -q 'tpm2'; then
            echo "Re-enrolling TPM2 on $dev"
            systemd-cryptenroll --wipe-slot=tpm2 --tpm2-device=auto --tpm2-pcrs=7+11 "$dev"
          else
            echo "No TPM2 token on $dev, skipping re-enroll"
          fi
        fi
      done

- name: Add pacman hook to re-enroll TPM after kernel changes
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/pacman.d/hooks/95-tpm2-reenroll.hook
    content: |
      [Trigger]
      Operation = Install
      Operation = Upgrade
      Type = Package
      Target = {{ kernel }}
      Target = mkinitcpio
      Target = systemd
      Target = systemd-boot

      [Action]
      Description = Re-enroll TPM2 key for all LUKS2 devices
      When = PostTransaction
      Exec = /usr/local/bin/reenroll-tpm-all.sh

- name: Fail if /mnt/usr/lib/initcpio/install/systemd-tool does not exist
  stat:
    path: /mnt/usr/lib/initcpio/install/systemd-tool
  register: systemd_tool_file

- name: Check if systemd-tool hook exists
  fail:
    msg: "/mnt/usr/lib/initcpio/install/systemd-tool does not exist"
  when: not systemd_tool_file.stat.exists
