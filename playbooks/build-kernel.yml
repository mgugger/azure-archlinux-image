---
- name: Set modules
  copy:
    dest: /mnt/etc/mkinitcpio.conf
    force: yes
    content: |
      MODULES=(hv_storvsc hv_vmbus hv_netvsc hv_utils keyboard zram btrfs)
      BINARIES=()
      FILES=()
      FIRMWARE=()
      HOOKS=(systemd systemd-tool autodetect modconf kms sd-vconsole block initrd_zram luks_unlocker sd-encrypt btrfs filesystems)
      COMPRESSION="zstd"
      COMPRESSION_OPTIONS=(-9)

- name: Set modules for fallback
  copy:
    dest: /mnt/etc/mkinitcpio-fallback.conf
    force: yes
    content: |
      MODULES=(hv_storvsc hv_vmbus hv_netvsc keyboard zram btrfs)
      BINARIES=()
      FILES=()
      FIRMWARE=()
      HOOKS=(systemd systemd-tool autodetect modconf kms sd-vconsole block initrd_zram sd-encrypt btrfs filesystems)
      COMPRESSION="zstd"
      COMPRESSION_OPTIONS=(-9)

- name: Create /etc/cmdline.d directory
  ansible.builtin.file:
    path: /mnt/etc/cmdline.d
    state: directory

- name: Create /etc/cmdline.d/default directory
  ansible.builtin.file:
    path: /mnt/etc/cmdline.d/default
    state: directory

- name: Create /etc/cmdline.d/fallback directory
  ansible.builtin.file:
    path: /mnt/etc/cmdline.d/fallback
    state: directory

- name: Get the UUID of the LUKS partition at {{ install_device_name }}{{ root_partition_number }}
  command: blkid -s UUID -o value {{ install_device_name }}{{ root_partition_number }}
  register: luks_partition_uuid

- name: set cmdline root conf for UKI
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/cmdline.d/default/root.conf
    content: |
      rd.luks.name={{ luks_partition_uuid.stdout }}={{ luks_root_name }} root=/dev/mapper/{{ luks_root_name }} rootflags=subvol=@ rw rd.neednet=1 console=tty0 console=ttyS0,115200 bgrt_disable lsm=landlock,lockdown,yama,integrity,apparmor,bpf slab_nomerge init_on_alloc=1 init_on_free=1 page_alloc.shuffle=1 pti=on randomize_kstack_offset=on vsyscall=none debugfs=off oops=panic intel_iommu=on amd_iommu=on

- name: set cmdline fallback conf for UKI
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/cmdline.d/fallback/root.conf
    content: |
      rd.luks.name={{ luks_partition_uuid.stdout }}={{ luks_root_name }} root=/dev/mapper/{{ luks_root_name }} rootflags=subvol=@ rw rd.neednet=1 console=tty0 console=ttyS0,115200 bgrt_disable lsm=landlock,lockdown,yama,integrity,apparmor,bpf slab_nomerge init_on_alloc=1 init_on_free=1 page_alloc.shuffle=1 pti=on randomize_kstack_offset=on vsyscall=none debugfs=off oops=panic intel_iommu=on amd_iommu=on

- name: Create systemd-networkd config directory
  ansible.builtin.file:
    path: /mnt/etc/systemd/network
    state: directory

- name: Create mkinitcpio-systemd-tool config directory
  ansible.builtin.file:
    path: /mnt/etc/mkinitcpio-systemd-tool/config
    state: directory

- name: Configure initrd network (DHCP) for systemd-tool
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/mkinitcpio-systemd-tool/config/initrd-network.network
    content: |
      [Match]
      Name=en*
      Name=eth*

      [Network]
      DHCP=yes
      DNS=9.9.9.9
      DNS=1.1.1.1

- name: Configure runtime network (DHCP)
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/systemd/network/20-wired.network
    content: |
      [Match]
      Name=en*
      Name=eth*

      [Network]
      DHCP=yes
      DNS=9.9.9.9
      DNS=1.1.1.1

- name: set /etc/mkinitcpio.d/{{ kernel }}.preset
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/mkinitcpio.d/{{ kernel }}.preset
    content: |
      ALL_kver="/boot/vmlinuz-{{ kernel }}"
      PRESETS=('default' 'fallback')
      default_uki="/efi/EFI/Linux/arch-linux.efi"
      default_config="/etc/mkinitcpio.conf"
      default_options="--cmdline /etc/cmdline.d/default/root.conf"
      fallback_uki="/efi/EFI/Linux/arch-linux-fallback.efi"
      fallback_options="--cmdline /etc/cmdline.d/fallback/root.conf"
      fallback_config="/etc/mkinitcpio-fallback.conf"

- name: Set initrd_zram install hook
  copy:
    dest: /mnt/etc/initcpio/install/initrd_zram
    force: yes
    content: |
      #!/bin/bash

      build() {
          # zram-generator: generator binary, template service, config, and tools
          add_binary /usr/lib/systemd/system-generators/zram-generator
          add_systemd_unit systemd-zram-setup@.service
          add_file /etc/systemd/zram-generator.conf
          add_binary /usr/bin/zramctl
          add_binary /usr/bin/mkswap
          add_binary /usr/bin/swapon
      }

      help() {
          cat <<HELPEOF
      Includes zram-generator and its dependencies in the initramfs
      so that zram swap is available during early boot.
      HELPEOF
      }

- name: Ensure /etc/initcpio/install/initrd_zram is executable
  file:
    path: /mnt/etc/initcpio/install/initrd_zram
    mode: "0755"

- name: Set luks_unlocker install
  copy:
    dest: /mnt/etc/initcpio/install/luks_unlocker
    force: yes
    content: |
      #!/bin/bash

      build() {
          add_binary /usr/local/bin/luks_unlocker /usr/local/bin/luks_unlocker
          add_binary /usr/lib/systemd/systemd-networkd-wait-online
          add_systemd_unit luks_unlocker.service
          add_systemd_unit systemd-networkd-wait-online.service
          add_systemd_unit systemd-resolved.service
          add_systemd_unit cryptsetup-pre.target

          # Enable the service by creating the .wants/ symlink.
          # add_systemd_unit only copies the unit file — it does NOT process
          # the [Install] section, so WantedBy= has no effect without this.
          add_symlink "/usr/lib/systemd/system/initrd.target.wants/luks_unlocker.service" \
                      "/usr/lib/systemd/system/luks_unlocker.service"

          # libnss_files.so is loaded via dlopen() — needed for passwd/group
          # lookups from /etc/passwd and /etc/group in the initramfs.
          # nsswitch.conf is already provisioned by the base systemd hook.
          local nss
          for nss in /usr/lib/libnss_files.so*; do
              [ -e "$nss" ] && add_binary "$nss"
          done

          # Add systemd-network and systemd-resolve users/groups/shadow to initramfs
          # (systemd-sysusers is not available in early boot)
          local user
          for user in systemd-network systemd-resolve; do
              grep -q "^${user}:" "$BUILDROOT/etc/passwd" || \
                  grep "^${user}:" /etc/passwd >> "$BUILDROOT/etc/passwd"
              grep -q "^${user}:" "$BUILDROOT/etc/group" || \
                  grep "^${user}:" /etc/group >> "$BUILDROOT/etc/group"
              grep -q "^${user}:" "$BUILDROOT/etc/shadow" 2>/dev/null || \
                  grep "^${user}:" /etc/shadow >> "$BUILDROOT/etc/shadow" 2>/dev/null
          done
      }

      help() {
          cat <<HELPEOF
      HELPEOF
      }

- name: Ensure /etc/initcpio/install/luks_unlocker
  file:
    path: /mnt/etc/initcpio/install/luks_unlocker
    mode: "0755"

- name: Set luks_unlocker install
  copy:
    dest: /mnt/usr/lib/systemd/system/luks_unlocker.service
    force: yes
    content: |
      [Unit]
      Description=Unlock LUKS with KeyVault
      DefaultDependencies=no
      Wants=cryptsetup-pre.target systemd-networkd.service systemd-resolved.service systemd-networkd-wait-online.service
      After=cryptsetup-pre.target systemd-networkd.service systemd-resolved.service systemd-networkd-wait-online.service
      Before=systemd-cryptsetup@{{ luks_root_name }}.service initrd-root-device.target
      Conflicts=systemd-cryptsetup@{{ luks_root_name }}.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes

      ExecStart=/bin/sh -c '/usr/lib/systemd/systemd-cryptsetup attach {{ luks_root_name }} /dev/disk/by-uuid/{{ luks_partition_uuid.stdout }} - tpm2-device=auto,headless=true || { /usr/lib/systemd/systemd-cryptsetup detach {{ luks_root_name }} 2>/dev/null; /usr/local/bin/luks_unlocker; }'
      Restart=on-failure
      RestartSec=10s
      StandardError=journal+console
      StandardOutput=journal+console

      [Install]
      WantedBy=initrd.target

- name: Download luks_unlocker zip
  get_url:
    url: https://github.com/mgugger/azure-keyvault-unlock-luks/releases/download/v0.0.1/azure-keyvault-unlock-luks_x86_64.zip
    dest: /tmp/luks_unlocker.zip

- name: Unpack luks_unlocker zip
  unarchive:
    src: /tmp/luks_unlocker.zip
    dest: /mnt/usr/local/bin
    remote_src: yes

- name: Ensure luks_unlocker is executable
  file:
    path: /mnt/usr/local/bin/luks_unlocker
    mode: "0755"

- name: Install first-boot TPM enroll script
  copy:
    dest: /mnt/usr/local/bin/enroll-tpm-all.sh
    mode: "0755"
    force: yes
    content: |
      #!/bin/bash
      set -euo pipefail
      for dev in $(blkid -t TYPE=crypto_LUKS -o device); do
        if cryptsetup isLuks --type luks2 "$dev" 2>/dev/null; then
          if cryptsetup luksDump "$dev" | grep -q 'tpm2'; then
            echo "TPM2 token already enrolled on $dev, skipping"
          else
            echo "Enrolling TPM2 on $dev"
            systemd-cryptenroll --tpm2-device=auto "$dev"
          fi
        fi
      done

- name: Install first-boot TPM enroll service
  copy:
    dest: /mnt/etc/systemd/system/enroll-tpm.service
    force: yes
    content: |
      [Unit]
      Description=Enroll TPM2 key for all LUKS2 devices
      ConditionFirstBoot=yes

      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/enroll-tpm-all.sh

      [Install]
      WantedBy=multi-user.target

- name: Disable first-boot TPM enroll service by default
  command:
    argv:
      - /usr/bin/systemctl
      - --root=/mnt
      - disable
      - enroll-tpm.service
  failed_when: false

- name: Ensure /etc/kernel exists in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/mkdir
      - -p
      - /etc/kernel

- name: Write /etc/kernel/uki.conf
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/kernel/uki.conf
    content: |
      [UKI]
      SecureBootPrivateKey=/etc/kernel/secure-boot-private-key.pem
      SecureBootCertificate=/etc/kernel/secure-boot-certificate.pem

- name: Install UKI tooling (base) in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/pacman
      - -S
      - --noconfirm
      - systemd-ukify
      - sbsigntools

- name: Generate Secure Boot keys manually (custom subject)
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/openssl
      - req
      - -new
      - -x509
      - -nodes
      - -days
      - "3650"
      - -subj
      - "/CN=Arch Secure Boot/O=mdgcorp/C=CH"
      - -keyout
      - /etc/kernel/secure-boot-private-key.pem
      - -out
      - /etc/kernel/secure-boot-certificate.pem

- name: Install mkinitcpio-systemd-tool (triggers hooks)
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/pacman
      - -S
      - --noconfirm
      - mkinitcpio-systemd-tool
      - mokutil

- name: Enable initrd-network.service in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/systemctl
      - enable
      - initrd-network.service

- name: Enable systemd-resolved in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/systemctl
      - enable
      - systemd-resolved.service

- name: Set timezone symlink in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/ln
      - -sf
      - /usr/share/zoneinfo/CET
      - /etc/localtime

- name: Sync hardware clock in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/hwclock
      - --systohc

- name: Generate locales in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/locale-gen

- name: Set root password in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /bin/bash
      - -c
      - echo -e "{{root_pw}}\n{{root_pw}}" | passwd

- name: Ensure EFI Linux output directory exists in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/mkdir
      - -p
      - /efi/EFI/Linux

- name: Create systemd system.conf.d directory for TMPDIR override
  ansible.builtin.file:
    path: /mnt/etc/systemd/system.conf.d
    state: directory

- name: Set TMPDIR=/var/tmp globally for all systemd services
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/systemd/system.conf.d/tmpdir.conf
    content: |
      [Manager]
      DefaultEnvironment=TMPDIR=/var/tmp

- name: Generate UKIs with mkinitcpio preset in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/mkinitcpio
      - -p
      - "{{ kernel }}"

- name: Sign systemd-boot EFI binary in chroot
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/lib/systemd/systemd-sbsign
      - sign
      - --private-key
      - /etc/kernel/secure-boot-private-key.pem
      - --certificate
      - /etc/kernel/secure-boot-certificate.pem
      - --output
      - /usr/lib/systemd/boot/efi/systemd-bootx64.efi.signed
      - /usr/lib/systemd/boot/efi/systemd-bootx64.efi

- name: Show free space on ESP (/mnt/efi)
  command:
    argv:
      - /usr/bin/df
      - -h
      - /mnt/efi
  register: esp_df

- name: Print ESP free space
  debug:
    var: esp_df.stdout_lines

- name: Install systemd-boot with Secure Boot
  command:
    argv:
      - /usr/bin/bootctl
      - --root=/mnt
      - install
      - --certificate
      - /mnt/etc/kernel/secure-boot-certificate.pem
      - --private-key
      - /mnt/etc/kernel/secure-boot-private-key.pem

- name: Create systemd-boot-update drop-in directory
  ansible.builtin.file:
    path: /mnt/etc/systemd/system/systemd-boot-update.service.d
    state: directory

- name: Override systemd-boot-update to sign the bootloader
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/systemd/system/systemd-boot-update.service.d/signing.conf
    content: |
      [Service]
      ExecStart=
      ExecStart=/usr/bin/bootctl update --certificate /etc/kernel/secure-boot-certificate.pem --private-key /etc/kernel/secure-boot-private-key.pem

- name: Install shim-signed from AUR using yay
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /bin/bash
      - -c
      - |
        sudo -u tmpuser yay -S --noconfirm shim-signed

- name: Convert certificate to DER for MokManager
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/bin/openssl
      - x509
      - -in
      - /etc/kernel/secure-boot-certificate.pem
      - -outform
      - DER
      - -out
      - /efi/mok-manager.crt

- name: Verify EFI Linux directory exists on ESP
  stat:
    path: /mnt/efi/EFI/Linux
  register: efi_linux_dir

- name: Fail if EFI Linux directory is missing
  fail:
    msg: "Missing /mnt/efi/EFI/Linux after kernel build; UKI artifacts were not generated on the ESP."
  when: not efi_linux_dir.stat.exists or not efi_linux_dir.stat.isdir

- name: Find generated UKI artifacts in EFI/Linux
  find:
    paths: /mnt/efi/EFI/Linux
    patterns: "*.efi"
    file_type: file
  register: efi_uki_files

- name: Fail if no UKI artifacts were generated in EFI/Linux
  fail:
    msg: "No UKI .efi files found in /mnt/efi/EFI/Linux after kernel build."
  when: efi_uki_files.matched | int == 0

- name: Export Secure Boot db certificate for build output
  command:
    argv:
      - /usr/bin/cp
      - /mnt/etc/kernel/secure-boot-certificate.pem
      - /tmp/secureboot-cert.pem

- name: Create pacman hooks directory for Secure Boot
  ansible.builtin.file:
    path: /mnt/etc/pacman.d/hooks
    state: directory

- name: Install secure boot resign script
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/usr/local/bin/secure-boot-resign
    mode: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail
      export TMPDIR=/var/tmp

      # Re-sign and install systemd-boot on ESP (updates BOOTX64.EFI)
      /usr/bin/bootctl update \
        --certificate /etc/kernel/secure-boot-certificate.pem \
        --private-key /etc/kernel/secure-boot-private-key.pem \
        --no-pager || true

      # Rename systemd-boot to grubx64.efi so shim loads it
      cp /efi/EFI/BOOT/BOOTX64.EFI /efi/EFI/BOOT/grubx64.efi

      # Install shim and MokManager
      cp /usr/share/shim-signed/shimx64.efi /efi/EFI/BOOT/BOOTX64.EFI
      cp /usr/share/shim-signed/mmx64.efi /efi/EFI/BOOT/mmx64.efi

- name: Initial run of secure-boot-resign to setup shim
  command:
    argv:
      - /usr/bin/arch-chroot
      - /mnt
      - /usr/local/bin/secure-boot-resign

- name: Add pacman hook to resign boot artifacts
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/pacman.d/hooks/90-sbctl-resign.hook
    content: |
      [Trigger]
      Operation = Install
      Operation = Upgrade
      Type = Package
      Target = systemd
      Target = systemd-boot

      [Action]
      Description = Regenerate UKIs and sign systemd-boot
      When = PostTransaction
      Exec = /usr/local/bin/secure-boot-resign

- name: Install secure boot setup script
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/usr/local/sbin/setup-secureboot.sh
    mode: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail

      log() { echo "[setup-secureboot] $*"; }

      CRT_PATH="/efi/mok-manager.crt"
      PEM_PATH="/tmp/mok-check.pem"
      BOOTLOADER="/efi/EFI/BOOT/grubx64.efi"

      log "Verifying signatures against ${CRT_PATH}..."
      openssl x509 -in "${CRT_PATH}" -inform DER -out "${PEM_PATH}"

      sbverify --cert "${PEM_PATH}" "${BOOTLOADER}" >/dev/null
      log "OK: ${BOOTLOADER}"

      while read -r efi_file; do
        case "${efi_file}" in
          *"/BOOTX64.EFI"|*"/mmx64.efi"|*"/shimx64.efi"|*"/grubx64.efi") continue ;;
        esac
        sbverify --cert "${PEM_PATH}" "${efi_file}" >/dev/null
        log "OK: ${efi_file}"
      done < <(find /efi -type f -name "*.efi")

      rm -f "${PEM_PATH}"

      log "Importing MOK certificate..."
      mokutil --import "${CRT_PATH}"

- name: Install setup script to enroll arch_root TPM2 token
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/usr/local/sbin/setup-tpm-arch-root.sh
    mode: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail

      log() { echo "[setup-tpm-arch-root] $*"; }

      ROOT_NAME="arch_root"

      extract_uuid() {
        local f="$1"
        [ -f "$f" ] || return 1
        grep -oE "rd\.luks\.name=[0-9a-fA-F-]+=${ROOT_NAME}" "$f" \
          | head -n1 \
          | sed -E "s/^rd\.luks\.name=([0-9a-fA-F-]+)=${ROOT_NAME}$/\1/"
      }

      ROOT_UUID="$(extract_uuid /etc/cmdline.d/default/root.conf || true)"
      if [ -z "${ROOT_UUID:-}" ]; then
        ROOT_UUID="$(extract_uuid /etc/cmdline.d/fallback/root.conf || true)"
      fi
      if [ -z "${ROOT_UUID:-}" ]; then
        ROOT_UUID="$(grep -oE "rd\.luks\.name=[0-9a-fA-F-]+=${ROOT_NAME}" /proc/cmdline \
          | head -n1 \
          | sed -E "s/^rd\.luks\.name=([0-9a-fA-F-]+)=${ROOT_NAME}$/\1/" || true)"
      fi

      if [ -z "${ROOT_UUID:-}" ]; then
        log "Could not determine ${ROOT_NAME} LUKS UUID from cmdline files or /proc/cmdline."
        exit 1
      fi

      ROOT_DEV="/dev/disk/by-uuid/${ROOT_UUID}"
      if [ ! -e "$ROOT_DEV" ]; then
        log "Device not found for UUID ${ROOT_UUID}: ${ROOT_DEV}"
        exit 1
      fi

      ROOT_DEV_REAL="$(readlink -f "$ROOT_DEV")"
      log "Resolved ${ROOT_NAME} to ${ROOT_DEV_REAL} (UUID=${ROOT_UUID})"

      if ! cryptsetup isLuks --type luks2 "$ROOT_DEV_REAL" >/dev/null 2>&1; then
        log "${ROOT_DEV_REAL} is not LUKS2. Aborting."
        exit 1
      fi

      if cryptsetup luksDump "$ROOT_DEV_REAL" | grep -q "systemd-tpm2"; then
        log "TPM2 token already present on ${ROOT_DEV_REAL}. Nothing to do."
        exit 0
      fi

      log "Enrolling TPM2 token on ${ROOT_DEV_REAL} (interactive auth may be requested)..."
      systemd-cryptenroll --tpm2-device=auto "$ROOT_DEV_REAL"

      if cryptsetup luksDump "$ROOT_DEV_REAL" | grep -q "systemd-tpm2"; then
        log "TPM2 enrollment successful for ${ROOT_NAME}."
      else
        log "TPM2 enrollment command returned, but token not detected."
        exit 1
      fi

- name: Install TPM re-enroll script
  copy:
    dest: /mnt/usr/local/bin/reenroll-tpm-all.sh
    mode: "0755"
    owner: root
    group: root
    force: yes
    content: |
      #!/bin/bash
      set -euo pipefail

      # Non-interactive guard: skip when no controlling TTY is available.
      # systemd-cryptenroll may prompt for an existing passphrase; in unattended
      # contexts this would block or fail.
      if [ ! -t 0 ] || [ ! -t 1 ]; then
        echo "Skipping TPM2 re-enroll: non-interactive session (no TTY)"
        exit 0
      fi

      for dev in $(blkid -t TYPE=crypto_LUKS -o device); do
        if cryptsetup isLuks --type luks2 "$dev" 2>/dev/null; then
          if cryptsetup luksDump "$dev" | grep -q 'tpm2'; then
            echo "Re-enrolling TPM2 on $dev"
            systemd-cryptenroll --unlock-tpm2-device=auto --wipe-slot=tpm2 --tpm2-device=auto "$dev"
            echo "TPM2 re-enrolled successfully on $dev"
          else
            echo "No TPM2 token on $dev, skipping re-enroll"
          fi
        fi
      done

- name: Add pacman hook to re-enroll TPM after kernel changes
  copy:
    owner: root
    group: root
    force: yes
    dest: /mnt/etc/pacman.d/hooks/95-tpm2-reenroll.hook
    content: |
      [Trigger]
      Operation = Install
      Operation = Upgrade
      Type = Package
      Target = {{ kernel }}
      Target = mkinitcpio
      Target = systemd
      Target = systemd-boot

      [Action]
      Description = Re-enroll TPM2 key for all LUKS2 devices
      When = PostTransaction
      Exec = /usr/local/bin/reenroll-tpm-all.sh

- name: Fail if /mnt/usr/lib/initcpio/install/systemd-tool does not exist
  stat:
    path: /mnt/usr/lib/initcpio/install/systemd-tool
  register: systemd_tool_file

- name: Check if systemd-tool hook exists
  fail:
    msg: "/mnt/usr/lib/initcpio/install/systemd-tool does not exist"
  when: not systemd_tool_file.stat.exists
